{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport { CancelledError, Console, functionalUpdate, isCancelable, isCancelledError, isDocumentVisible, isOnline, isServer, isValidTimeout, noop, replaceEqualDeep, sleep } from './utils';\nimport { QueryStatus } from './types';\nimport { QueryObserver } from './queryObserver';\nimport { notifyManager } from './notifyManager'; // TYPES\n\nfunction _empty() {}\n\nvar ActionType = {\n  Failed: 0,\n  Fetch: 1,\n  Success: 2,\n  Error: 3,\n  Invalidate: 4\n}; // CLASS\n\nfunction _awaitIgnored(value, direct) {\n  if (!direct) {\n    return value && value.then ? value.then(_empty) : Promise.resolve();\n  }\n}\n\nfunction _invoke(body, then) {\n  var result = body();\n\n  if (result && result.then) {\n    return result.then(then);\n  }\n\n  return then(result);\n}\n\nfunction _await(value, then, direct) {\n  if (direct) {\n    return then ? then(value) : value;\n  }\n\n  if (!value || !value.then) {\n    value = Promise.resolve(value);\n  }\n\n  return then ? value.then(then) : value;\n}\n\nfunction _catch(body, recover) {\n  try {\n    var result = body();\n  } catch (e) {\n    return recover(e);\n  }\n\n  if (result && result.then) {\n    return result.then(void 0, recover);\n  }\n\n  return result;\n}\n\nfunction _async(f) {\n  return function () {\n    for (var args = [], i = 0; i < arguments.length; i++) {\n      args[i] = arguments[i];\n    }\n\n    try {\n      return Promise.resolve(f.apply(this, args));\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n}\n\nexport var Query = /*#__PURE__*/function () {\n  function Query(config) {\n    this.config = config;\n    this.queryKey = config.queryKey;\n    this.queryHash = config.queryHash;\n    this.queryCache = config.queryCache;\n    this.cacheTime = config.cacheTime;\n    this.observers = [];\n    this.state = getDefaultState(config);\n    this.scheduleGc();\n  }\n\n  var _proto = Query.prototype;\n\n  _proto.updateConfig = function updateConfig(config) {\n    this.config = config;\n    this.cacheTime = Math.max(this.cacheTime, config.cacheTime);\n  };\n\n  _proto.dispatch = function dispatch(action) {\n    var _this = this;\n\n    this.state = queryReducer(this.state, action);\n    notifyManager.batch(function () {\n      _this.observers.forEach(function (observer) {\n        observer.onQueryUpdate(action);\n      });\n\n      _this.queryCache.notifyGlobalListeners(_this);\n    });\n  };\n\n  _proto.scheduleGc = function scheduleGc() {\n    var _this2 = this;\n\n    if (isServer) {\n      return;\n    }\n\n    this.clearGcTimeout();\n\n    if (this.observers.length > 0 || !isValidTimeout(this.cacheTime)) {\n      return;\n    }\n\n    this.gcTimeout = setTimeout(function () {\n      _this2.remove();\n    }, this.cacheTime);\n  };\n\n  _proto.cancel = function cancel(silent) {\n    var promise = this.promise;\n\n    if (promise && this.cancelFetch) {\n      this.cancelFetch(silent);\n      return promise.then(noop).catch(noop);\n    }\n\n    return Promise.resolve(undefined);\n  };\n\n  _proto.continue = function _continue() {\n    var _this$continueFetch;\n\n    (_this$continueFetch = this.continueFetch) == null ? void 0 : _this$continueFetch.call(this);\n  };\n\n  _proto.clearTimersObservers = function clearTimersObservers() {\n    this.observers.forEach(function (observer) {\n      observer.clearTimers();\n    });\n  };\n\n  _proto.clearGcTimeout = function clearGcTimeout() {\n    if (this.gcTimeout) {\n      clearTimeout(this.gcTimeout);\n      this.gcTimeout = undefined;\n    }\n  };\n\n  _proto.setData = function setData(updater, options) {\n    var _this$config$isDataEq, _this$config;\n\n    var prevData = this.state.data; // Get the new data\n\n    var data = functionalUpdate(updater, prevData); // Structurally share data between prev and new data if needed\n\n    if (this.config.structuralSharing) {\n      data = replaceEqualDeep(prevData, data);\n    } // Use prev data if an isDataEqual function is defined and returns `true`\n\n\n    if ((_this$config$isDataEq = (_this$config = this.config).isDataEqual) == null ? void 0 : _this$config$isDataEq.call(_this$config, prevData, data)) {\n      data = prevData;\n    } // Try to determine if more data can be fetched\n\n\n    var canFetchMore = hasMorePages(this.config, data); // Set data and mark it as cached\n\n    this.dispatch({\n      type: ActionType.Success,\n      data: data,\n      canFetchMore: canFetchMore,\n      updatedAt: options == null ? void 0 : options.updatedAt\n    });\n  }\n  /**\n   * @deprecated\n   */\n  ;\n\n  _proto.clear = function clear() {\n    Console.warn('react-query: clear() has been deprecated, please use remove() instead');\n    this.remove();\n  };\n\n  _proto.remove = function remove() {\n    this.queryCache.removeQuery(this);\n  };\n\n  _proto.destroy = function destroy() {\n    this.clearGcTimeout();\n    this.clearTimersObservers();\n    this.cancel();\n  };\n\n  _proto.isActive = function isActive() {\n    return this.observers.some(function (observer) {\n      return observer.config.enabled;\n    });\n  };\n\n  _proto.isStale = function isStale() {\n    return this.state.isInvalidated || this.state.status !== QueryStatus.Success || this.observers.some(function (observer) {\n      return observer.getCurrentResult().isStale;\n    });\n  };\n\n  _proto.isStaleByTime = function isStaleByTime(staleTime) {\n    if (staleTime === void 0) {\n      staleTime = 0;\n    }\n\n    return this.state.isInvalidated || this.state.status !== QueryStatus.Success || this.state.updatedAt + staleTime <= Date.now();\n  };\n\n  _proto.onInteraction = function onInteraction(type) {\n    // Execute the first observer which is enabled,\n    // stale and wants to refetch on this interaction.\n    var staleObserver = this.observers.find(function (observer) {\n      var config = observer.config;\n\n      var _observer$getCurrentR = observer.getCurrentResult(),\n          isStale = _observer$getCurrentR.isStale;\n\n      return config.enabled && (type === 'focus' && (config.refetchOnWindowFocus === 'always' || config.refetchOnWindowFocus && isStale) || type === 'online' && (config.refetchOnReconnect === 'always' || config.refetchOnReconnect && isStale));\n    });\n\n    if (staleObserver) {\n      staleObserver.fetch();\n    } // Continue any paused fetch\n\n\n    this.continue();\n  }\n  /**\n   * @deprectated\n   */\n  ;\n\n  _proto.subscribe = function subscribe(listener) {\n    var observer = new QueryObserver(this.config);\n    observer.subscribe(listener);\n    return observer;\n  };\n\n  _proto.subscribeObserver = function subscribeObserver(observer) {\n    this.observers.push(observer); // Stop the query from being garbage collected\n\n    this.clearGcTimeout();\n  };\n\n  _proto.unsubscribeObserver = function unsubscribeObserver(observer) {\n    this.observers = this.observers.filter(function (x) {\n      return x !== observer;\n    });\n\n    if (!this.observers.length) {\n      // If the transport layer does not support cancellation\n      // we'll let the query continue so the result can be cached\n      if (this.isTransportCancelable) {\n        this.cancel();\n      }\n\n      this.scheduleGc();\n    }\n  };\n\n  _proto.invalidate = function invalidate() {\n    if (!this.state.isInvalidated) {\n      this.dispatch({\n        type: ActionType.Invalidate\n      });\n    }\n  }\n  /**\n   * @deprectated\n   */\n  ;\n\n  _proto.refetch = function refetch(options, config) {\n    var promise = this.fetch(undefined, config);\n\n    if (!(options == null ? void 0 : options.throwOnError)) {\n      promise = promise.catch(noop);\n    }\n\n    return promise;\n  }\n  /**\n   * @deprectated\n   */\n  ;\n\n  _proto.fetchMore = function fetchMore(fetchMoreVariable, options, config) {\n    return this.fetch({\n      fetchMore: {\n        fetchMoreVariable: fetchMoreVariable,\n        previous: (options == null ? void 0 : options.previous) || false\n      }\n    }, config);\n  };\n\n  _proto.fetch = function fetch(options, config) {\n    try {\n      var _exit2 = false;\n\n      var _this4 = this;\n\n      return _invoke(function () {\n        if (_this4.promise) {\n          return function () {\n            if ((options == null ? void 0 : options.fetchMore) && _this4.state.data) {\n              // Silently cancel current fetch if the user wants to fetch more\n              return _awaitIgnored(_this4.cancel(true));\n            } else {\n              // Return current promise if we are already fetching\n              _exit2 = true;\n              return _this4.promise;\n            }\n          }();\n        }\n      }, function (_result2) {\n        if (_exit2) return _result2; // Update config if passed, otherwise the config from the last execution is used\n\n        if (config) {\n          _this4.updateConfig(config);\n        }\n\n        config = _this4.config; // Get the query function params\n\n        var filter = config.queryFnParamsFilter;\n        var params = filter ? filter(_this4.queryKey) : _this4.queryKey;\n        _this4.promise = _async(function () {\n          return _catch(function () {\n            var data;\n            return _invoke(function () {\n              if (config.infinite) {\n                return _await(_this4.startInfiniteFetch(config, params, options), function (_this4$startInfiniteF) {\n                  data = _this4$startInfiniteF;\n                });\n              } else {\n                return _await(_this4.startFetch(config, params, options), function (_this4$startFetch) {\n                  data = _this4$startFetch;\n                });\n              }\n            }, function () {\n              // Set success state\n              _this4.setData(data); // Cleanup\n\n\n              delete _this4.promise; // Return data\n\n              return data;\n            });\n          }, function (error) {\n            // Set error state if needed\n            if (!(isCancelledError(error) && error.silent)) {\n              _this4.dispatch({\n                type: ActionType.Error,\n                error: error\n              });\n            } // Log error\n\n\n            if (!isCancelledError(error)) {\n              Console.error(error);\n            } // Cleanup\n\n\n            delete _this4.promise; // Propagate error\n\n            throw error;\n          });\n        })();\n        return _this4.promise;\n      });\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n\n  _proto.startFetch = function startFetch(config, params, _options) {\n    // Create function to fetch the data\n    var fetchData = function fetchData() {\n      return config.queryFn.apply(config, params);\n    }; // Set to fetching state if not already in it\n\n\n    if (!this.state.isFetching) {\n      this.dispatch({\n        type: ActionType.Fetch\n      });\n    } // Try to fetch the data\n\n\n    return this.tryFetchData(config, fetchData);\n  };\n\n  _proto.startInfiniteFetch = function startInfiniteFetch(config, params, options) {\n    var fetchMore = options == null ? void 0 : options.fetchMore;\n\n    var _ref = fetchMore || {},\n        previous = _ref.previous,\n        fetchMoreVariable = _ref.fetchMoreVariable;\n\n    var isFetchingMore = fetchMore ? previous ? 'previous' : 'next' : false;\n    var prevPages = this.state.data || []; // Create function to fetch a page\n\n    var fetchPage = _async(function (pages, prepend, cursor) {\n      var lastPage = getLastPage(pages, prepend);\n\n      if (typeof cursor === 'undefined' && typeof lastPage !== 'undefined' && config.getFetchMore) {\n        cursor = config.getFetchMore(lastPage, pages);\n      }\n\n      return !Boolean(cursor) && typeof lastPage !== 'undefined' ? pages : _await(config.queryFn.apply(config, params.concat([cursor])), function (page) {\n        return prepend ? [page].concat(pages) : [].concat(pages, [page]);\n      });\n    }); // Create function to fetch the data\n\n\n    var fetchData = function fetchData() {\n      if (isFetchingMore) {\n        return fetchPage(prevPages, previous, fetchMoreVariable);\n      } else if (!prevPages.length) {\n        return fetchPage([]);\n      } else {\n        var promise = fetchPage([]);\n\n        for (var i = 1; i < prevPages.length; i++) {\n          promise = promise.then(fetchPage);\n        }\n\n        return promise;\n      }\n    }; // Set to fetching state if not already in it\n\n\n    if (!this.state.isFetching || this.state.isFetchingMore !== isFetchingMore) {\n      this.dispatch({\n        type: ActionType.Fetch,\n        isFetchingMore: isFetchingMore\n      });\n    } // Try to get the data\n\n\n    return this.tryFetchData(config, fetchData);\n  };\n\n  _proto.tryFetchData = function tryFetchData(config, fn) {\n    var _this5 = this;\n\n    return new Promise(function (outerResolve, outerReject) {\n      var resolved = false;\n      var continueLoop;\n      var cancelTransport;\n\n      var done = function done() {\n        resolved = true;\n        delete _this5.cancelFetch;\n        delete _this5.continueFetch;\n        delete _this5.isTransportCancelable; // End loop if currently paused\n\n        continueLoop == null ? void 0 : continueLoop();\n      };\n\n      var resolve = function resolve(value) {\n        done();\n        outerResolve(value);\n      };\n\n      var reject = function reject(value) {\n        done();\n        outerReject(value);\n      }; // Create callback to cancel this fetch\n\n\n      _this5.cancelFetch = function (silent) {\n        reject(new CancelledError(silent));\n        cancelTransport == null ? void 0 : cancelTransport();\n      }; // Create callback to continue this fetch\n\n\n      _this5.continueFetch = function () {\n        continueLoop == null ? void 0 : continueLoop();\n      }; // Create loop function\n\n\n      var run = _async(function () {\n        return _catch(function () {\n          // Execute query\n          var promiseOrValue = fn(); // Check if the transport layer support cancellation\n\n          if (isCancelable(promiseOrValue)) {\n            cancelTransport = function cancelTransport() {\n              try {\n                promiseOrValue.cancel();\n              } catch (_unused) {}\n            };\n\n            _this5.isTransportCancelable = true;\n          } // Await data\n\n\n          return _await(promiseOrValue, function (_promiseOrValue) {\n            resolve(_promiseOrValue);\n          });\n        }, function (error) {\n          // Stop if the fetch is already resolved\n          if (resolved) {\n            return;\n          } // Do we need to retry the request?\n\n\n          var failureCount = _this5.state.failureCount;\n          var retry = config.retry,\n              retryDelay = config.retryDelay;\n          var shouldRetry = retry === true || failureCount < retry || typeof retry === 'function' && retry(failureCount, error);\n\n          if (!shouldRetry) {\n            // We are done if the query does not need to be retried\n            reject(error);\n            return;\n          } // Increase the failureCount\n\n\n          _this5.dispatch({\n            type: ActionType.Failed\n          }); // Delay\n\n\n          return _await(sleep(functionalUpdate(retryDelay, failureCount) || 0), function () {\n            // Pause retry if the document is not visible or when the device is offline\n            return _invoke(function () {\n              if (!isDocumentVisible() || !isOnline()) {\n                return _awaitIgnored(new Promise(function (continueResolve) {\n                  continueLoop = continueResolve;\n                }));\n              }\n            }, function () {\n              if (!resolved) {\n                run();\n              }\n            }); // Try again if not resolved yet\n          });\n        });\n      }); // Start loop\n\n\n      run();\n    });\n  };\n\n  return Query;\n}();\n\nfunction getLastPage(pages, previous) {\n  return previous ? pages[0] : pages[pages.length - 1];\n}\n\nfunction hasMorePages(config, pages, previous) {\n  if (config.infinite && config.getFetchMore && Array.isArray(pages)) {\n    return Boolean(config.getFetchMore(getLastPage(pages, previous), pages));\n  }\n}\n\nfunction getDefaultState(config) {\n  var data = typeof config.initialData === 'function' ? config.initialData() : config.initialData;\n  var status = typeof data !== 'undefined' ? QueryStatus.Success : config.enabled ? QueryStatus.Loading : QueryStatus.Idle;\n  return {\n    canFetchMore: hasMorePages(config, data),\n    data: data,\n    error: null,\n    failureCount: 0,\n    isFetching: status === QueryStatus.Loading,\n    isFetchingMore: false,\n    isInitialData: true,\n    isInvalidated: false,\n    status: status,\n    updateCount: 0,\n    updatedAt: Date.now()\n  };\n}\n\nexport function queryReducer(state, action) {\n  var _action$updatedAt;\n\n  switch (action.type) {\n    case ActionType.Failed:\n      return _extends({}, state, {\n        failureCount: state.failureCount + 1\n      });\n\n    case ActionType.Fetch:\n      return _extends({}, state, {\n        failureCount: 0,\n        isFetching: true,\n        isFetchingMore: action.isFetchingMore || false,\n        status: typeof state.data !== 'undefined' ? QueryStatus.Success : QueryStatus.Loading\n      });\n\n    case ActionType.Success:\n      return _extends({}, state, {\n        canFetchMore: action.canFetchMore,\n        data: action.data,\n        error: null,\n        failureCount: 0,\n        isFetching: false,\n        isFetchingMore: false,\n        isInitialData: false,\n        isInvalidated: false,\n        status: QueryStatus.Success,\n        updateCount: state.updateCount + 1,\n        updatedAt: (_action$updatedAt = action.updatedAt) != null ? _action$updatedAt : Date.now()\n      });\n\n    case ActionType.Error:\n      return _extends({}, state, {\n        error: action.error,\n        failureCount: state.failureCount + 1,\n        isFetching: false,\n        isFetchingMore: false,\n        status: QueryStatus.Error,\n        throwInErrorBoundary: true,\n        updateCount: state.updateCount + 1\n      });\n\n    case ActionType.Invalidate:\n      return _extends({}, state, {\n        isInvalidated: true\n      });\n\n    default:\n      return state;\n  }\n}","map":{"version":3,"sources":["/home/ali/hamnavazi/my-app/node_modules/react-query/es/core/query.js"],"names":["_extends","CancelledError","Console","functionalUpdate","isCancelable","isCancelledError","isDocumentVisible","isOnline","isServer","isValidTimeout","noop","replaceEqualDeep","sleep","QueryStatus","QueryObserver","notifyManager","_empty","ActionType","Failed","Fetch","Success","Error","Invalidate","_awaitIgnored","value","direct","then","Promise","resolve","_invoke","body","result","_await","_catch","recover","e","_async","f","args","i","arguments","length","apply","reject","Query","config","queryKey","queryHash","queryCache","cacheTime","observers","state","getDefaultState","scheduleGc","_proto","prototype","updateConfig","Math","max","dispatch","action","_this","queryReducer","batch","forEach","observer","onQueryUpdate","notifyGlobalListeners","_this2","clearGcTimeout","gcTimeout","setTimeout","remove","cancel","silent","promise","cancelFetch","catch","undefined","continue","_continue","_this$continueFetch","continueFetch","call","clearTimersObservers","clearTimers","clearTimeout","setData","updater","options","_this$config$isDataEq","_this$config","prevData","data","structuralSharing","isDataEqual","canFetchMore","hasMorePages","type","updatedAt","clear","warn","removeQuery","destroy","isActive","some","enabled","isStale","isInvalidated","status","getCurrentResult","isStaleByTime","staleTime","Date","now","onInteraction","staleObserver","find","_observer$getCurrentR","refetchOnWindowFocus","refetchOnReconnect","fetch","subscribe","listener","subscribeObserver","push","unsubscribeObserver","filter","x","isTransportCancelable","invalidate","refetch","throwOnError","fetchMore","fetchMoreVariable","previous","_exit2","_this4","_result2","queryFnParamsFilter","params","infinite","startInfiniteFetch","_this4$startInfiniteF","startFetch","_this4$startFetch","error","_options","fetchData","queryFn","isFetching","tryFetchData","_ref","isFetchingMore","prevPages","fetchPage","pages","prepend","cursor","lastPage","getLastPage","getFetchMore","Boolean","concat","page","fn","_this5","outerResolve","outerReject","resolved","continueLoop","cancelTransport","done","run","promiseOrValue","_unused","_promiseOrValue","failureCount","retry","retryDelay","shouldRetry","continueResolve","Array","isArray","initialData","Loading","Idle","isInitialData","updateCount","_action$updatedAt","throwInErrorBoundary"],"mappings":"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","sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport { CancelledError, Console, functionalUpdate, isCancelable, isCancelledError, isDocumentVisible, isOnline, isServer, isValidTimeout, noop, replaceEqualDeep, sleep } from './utils';\nimport { QueryStatus } from './types';\nimport { QueryObserver } from './queryObserver';\nimport { notifyManager } from './notifyManager'; // TYPES\n\nfunction _empty() {}\n\nvar ActionType = {\n  Failed: 0,\n  Fetch: 1,\n  Success: 2,\n  Error: 3,\n  Invalidate: 4\n};\n\n// CLASS\nfunction _awaitIgnored(value, direct) {\n  if (!direct) {\n    return value && value.then ? value.then(_empty) : Promise.resolve();\n  }\n}\n\nfunction _invoke(body, then) {\n  var result = body();\n\n  if (result && result.then) {\n    return result.then(then);\n  }\n\n  return then(result);\n}\n\nfunction _await(value, then, direct) {\n  if (direct) {\n    return then ? then(value) : value;\n  }\n\n  if (!value || !value.then) {\n    value = Promise.resolve(value);\n  }\n\n  return then ? value.then(then) : value;\n}\n\nfunction _catch(body, recover) {\n  try {\n    var result = body();\n  } catch (e) {\n    return recover(e);\n  }\n\n  if (result && result.then) {\n    return result.then(void 0, recover);\n  }\n\n  return result;\n}\n\nfunction _async(f) {\n  return function () {\n    for (var args = [], i = 0; i < arguments.length; i++) {\n      args[i] = arguments[i];\n    }\n\n    try {\n      return Promise.resolve(f.apply(this, args));\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n}\n\nexport var Query = /*#__PURE__*/function () {\n  function Query(config) {\n    this.config = config;\n    this.queryKey = config.queryKey;\n    this.queryHash = config.queryHash;\n    this.queryCache = config.queryCache;\n    this.cacheTime = config.cacheTime;\n    this.observers = [];\n    this.state = getDefaultState(config);\n    this.scheduleGc();\n  }\n\n  var _proto = Query.prototype;\n\n  _proto.updateConfig = function updateConfig(config) {\n    this.config = config;\n    this.cacheTime = Math.max(this.cacheTime, config.cacheTime);\n  };\n\n  _proto.dispatch = function dispatch(action) {\n    var _this = this;\n\n    this.state = queryReducer(this.state, action);\n    notifyManager.batch(function () {\n      _this.observers.forEach(function (observer) {\n        observer.onQueryUpdate(action);\n      });\n\n      _this.queryCache.notifyGlobalListeners(_this);\n    });\n  };\n\n  _proto.scheduleGc = function scheduleGc() {\n    var _this2 = this;\n\n    if (isServer) {\n      return;\n    }\n\n    this.clearGcTimeout();\n\n    if (this.observers.length > 0 || !isValidTimeout(this.cacheTime)) {\n      return;\n    }\n\n    this.gcTimeout = setTimeout(function () {\n      _this2.remove();\n    }, this.cacheTime);\n  };\n\n  _proto.cancel = function cancel(silent) {\n    var promise = this.promise;\n\n    if (promise && this.cancelFetch) {\n      this.cancelFetch(silent);\n      return promise.then(noop).catch(noop);\n    }\n\n    return Promise.resolve(undefined);\n  };\n\n  _proto.continue = function _continue() {\n    var _this$continueFetch;\n\n    (_this$continueFetch = this.continueFetch) == null ? void 0 : _this$continueFetch.call(this);\n  };\n\n  _proto.clearTimersObservers = function clearTimersObservers() {\n    this.observers.forEach(function (observer) {\n      observer.clearTimers();\n    });\n  };\n\n  _proto.clearGcTimeout = function clearGcTimeout() {\n    if (this.gcTimeout) {\n      clearTimeout(this.gcTimeout);\n      this.gcTimeout = undefined;\n    }\n  };\n\n  _proto.setData = function setData(updater, options) {\n    var _this$config$isDataEq, _this$config;\n\n    var prevData = this.state.data; // Get the new data\n\n    var data = functionalUpdate(updater, prevData); // Structurally share data between prev and new data if needed\n\n    if (this.config.structuralSharing) {\n      data = replaceEqualDeep(prevData, data);\n    } // Use prev data if an isDataEqual function is defined and returns `true`\n\n\n    if ((_this$config$isDataEq = (_this$config = this.config).isDataEqual) == null ? void 0 : _this$config$isDataEq.call(_this$config, prevData, data)) {\n      data = prevData;\n    } // Try to determine if more data can be fetched\n\n\n    var canFetchMore = hasMorePages(this.config, data); // Set data and mark it as cached\n\n    this.dispatch({\n      type: ActionType.Success,\n      data: data,\n      canFetchMore: canFetchMore,\n      updatedAt: options == null ? void 0 : options.updatedAt\n    });\n  }\n  /**\n   * @deprecated\n   */\n  ;\n\n  _proto.clear = function clear() {\n    Console.warn('react-query: clear() has been deprecated, please use remove() instead');\n    this.remove();\n  };\n\n  _proto.remove = function remove() {\n    this.queryCache.removeQuery(this);\n  };\n\n  _proto.destroy = function destroy() {\n    this.clearGcTimeout();\n    this.clearTimersObservers();\n    this.cancel();\n  };\n\n  _proto.isActive = function isActive() {\n    return this.observers.some(function (observer) {\n      return observer.config.enabled;\n    });\n  };\n\n  _proto.isStale = function isStale() {\n    return this.state.isInvalidated || this.state.status !== QueryStatus.Success || this.observers.some(function (observer) {\n      return observer.getCurrentResult().isStale;\n    });\n  };\n\n  _proto.isStaleByTime = function isStaleByTime(staleTime) {\n    if (staleTime === void 0) {\n      staleTime = 0;\n    }\n\n    return this.state.isInvalidated || this.state.status !== QueryStatus.Success || this.state.updatedAt + staleTime <= Date.now();\n  };\n\n  _proto.onInteraction = function onInteraction(type) {\n    // Execute the first observer which is enabled,\n    // stale and wants to refetch on this interaction.\n    var staleObserver = this.observers.find(function (observer) {\n      var config = observer.config;\n\n      var _observer$getCurrentR = observer.getCurrentResult(),\n          isStale = _observer$getCurrentR.isStale;\n\n      return config.enabled && (type === 'focus' && (config.refetchOnWindowFocus === 'always' || config.refetchOnWindowFocus && isStale) || type === 'online' && (config.refetchOnReconnect === 'always' || config.refetchOnReconnect && isStale));\n    });\n\n    if (staleObserver) {\n      staleObserver.fetch();\n    } // Continue any paused fetch\n\n\n    this.continue();\n  }\n  /**\n   * @deprectated\n   */\n  ;\n\n  _proto.subscribe = function subscribe(listener) {\n    var observer = new QueryObserver(this.config);\n    observer.subscribe(listener);\n    return observer;\n  };\n\n  _proto.subscribeObserver = function subscribeObserver(observer) {\n    this.observers.push(observer); // Stop the query from being garbage collected\n\n    this.clearGcTimeout();\n  };\n\n  _proto.unsubscribeObserver = function unsubscribeObserver(observer) {\n    this.observers = this.observers.filter(function (x) {\n      return x !== observer;\n    });\n\n    if (!this.observers.length) {\n      // If the transport layer does not support cancellation\n      // we'll let the query continue so the result can be cached\n      if (this.isTransportCancelable) {\n        this.cancel();\n      }\n\n      this.scheduleGc();\n    }\n  };\n\n  _proto.invalidate = function invalidate() {\n    if (!this.state.isInvalidated) {\n      this.dispatch({\n        type: ActionType.Invalidate\n      });\n    }\n  }\n  /**\n   * @deprectated\n   */\n  ;\n\n  _proto.refetch = function refetch(options, config) {\n    var promise = this.fetch(undefined, config);\n\n    if (!(options == null ? void 0 : options.throwOnError)) {\n      promise = promise.catch(noop);\n    }\n\n    return promise;\n  }\n  /**\n   * @deprectated\n   */\n  ;\n\n  _proto.fetchMore = function fetchMore(fetchMoreVariable, options, config) {\n    return this.fetch({\n      fetchMore: {\n        fetchMoreVariable: fetchMoreVariable,\n        previous: (options == null ? void 0 : options.previous) || false\n      }\n    }, config);\n  };\n\n  _proto.fetch = function fetch(options, config) {\n    try {\n      var _exit2 = false;\n\n      var _this4 = this;\n\n      return _invoke(function () {\n        if (_this4.promise) {\n          return function () {\n            if ((options == null ? void 0 : options.fetchMore) && _this4.state.data) {\n              // Silently cancel current fetch if the user wants to fetch more\n              return _awaitIgnored(_this4.cancel(true));\n            } else {\n              // Return current promise if we are already fetching\n              _exit2 = true;\n              return _this4.promise;\n            }\n          }();\n        }\n      }, function (_result2) {\n        if (_exit2) return _result2;\n\n        // Update config if passed, otherwise the config from the last execution is used\n        if (config) {\n          _this4.updateConfig(config);\n        }\n\n        config = _this4.config; // Get the query function params\n\n        var filter = config.queryFnParamsFilter;\n        var params = filter ? filter(_this4.queryKey) : _this4.queryKey;\n        _this4.promise = _async(function () {\n          return _catch(function () {\n            var data;\n            return _invoke(function () {\n              if (config.infinite) {\n                return _await(_this4.startInfiniteFetch(config, params, options), function (_this4$startInfiniteF) {\n                  data = _this4$startInfiniteF;\n                });\n              } else {\n                return _await(_this4.startFetch(config, params, options), function (_this4$startFetch) {\n                  data = _this4$startFetch;\n                });\n              }\n            }, function () {\n              // Set success state\n              _this4.setData(data); // Cleanup\n\n\n              delete _this4.promise; // Return data\n\n              return data;\n            });\n          }, function (error) {\n            // Set error state if needed\n            if (!(isCancelledError(error) && error.silent)) {\n              _this4.dispatch({\n                type: ActionType.Error,\n                error: error\n              });\n            } // Log error\n\n\n            if (!isCancelledError(error)) {\n              Console.error(error);\n            } // Cleanup\n\n\n            delete _this4.promise; // Propagate error\n\n            throw error;\n          });\n        })();\n        return _this4.promise;\n      });\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n\n  _proto.startFetch = function startFetch(config, params, _options) {\n    // Create function to fetch the data\n    var fetchData = function fetchData() {\n      return config.queryFn.apply(config, params);\n    }; // Set to fetching state if not already in it\n\n\n    if (!this.state.isFetching) {\n      this.dispatch({\n        type: ActionType.Fetch\n      });\n    } // Try to fetch the data\n\n\n    return this.tryFetchData(config, fetchData);\n  };\n\n  _proto.startInfiniteFetch = function startInfiniteFetch(config, params, options) {\n    var fetchMore = options == null ? void 0 : options.fetchMore;\n\n    var _ref = fetchMore || {},\n        previous = _ref.previous,\n        fetchMoreVariable = _ref.fetchMoreVariable;\n\n    var isFetchingMore = fetchMore ? previous ? 'previous' : 'next' : false;\n    var prevPages = this.state.data || []; // Create function to fetch a page\n\n    var fetchPage = _async(function (pages, prepend, cursor) {\n      var lastPage = getLastPage(pages, prepend);\n\n      if (typeof cursor === 'undefined' && typeof lastPage !== 'undefined' && config.getFetchMore) {\n        cursor = config.getFetchMore(lastPage, pages);\n      }\n\n      return !Boolean(cursor) && typeof lastPage !== 'undefined' ? pages : _await(config.queryFn.apply(config, params.concat([cursor])), function (page) {\n        return prepend ? [page].concat(pages) : [].concat(pages, [page]);\n      });\n    }); // Create function to fetch the data\n\n\n    var fetchData = function fetchData() {\n      if (isFetchingMore) {\n        return fetchPage(prevPages, previous, fetchMoreVariable);\n      } else if (!prevPages.length) {\n        return fetchPage([]);\n      } else {\n        var promise = fetchPage([]);\n\n        for (var i = 1; i < prevPages.length; i++) {\n          promise = promise.then(fetchPage);\n        }\n\n        return promise;\n      }\n    }; // Set to fetching state if not already in it\n\n\n    if (!this.state.isFetching || this.state.isFetchingMore !== isFetchingMore) {\n      this.dispatch({\n        type: ActionType.Fetch,\n        isFetchingMore: isFetchingMore\n      });\n    } // Try to get the data\n\n\n    return this.tryFetchData(config, fetchData);\n  };\n\n  _proto.tryFetchData = function tryFetchData(config, fn) {\n    var _this5 = this;\n\n    return new Promise(function (outerResolve, outerReject) {\n      var resolved = false;\n      var continueLoop;\n      var cancelTransport;\n\n      var done = function done() {\n        resolved = true;\n        delete _this5.cancelFetch;\n        delete _this5.continueFetch;\n        delete _this5.isTransportCancelable; // End loop if currently paused\n\n        continueLoop == null ? void 0 : continueLoop();\n      };\n\n      var resolve = function resolve(value) {\n        done();\n        outerResolve(value);\n      };\n\n      var reject = function reject(value) {\n        done();\n        outerReject(value);\n      }; // Create callback to cancel this fetch\n\n\n      _this5.cancelFetch = function (silent) {\n        reject(new CancelledError(silent));\n        cancelTransport == null ? void 0 : cancelTransport();\n      }; // Create callback to continue this fetch\n\n\n      _this5.continueFetch = function () {\n        continueLoop == null ? void 0 : continueLoop();\n      }; // Create loop function\n\n\n      var run = _async(function () {\n        return _catch(function () {\n          // Execute query\n          var promiseOrValue = fn(); // Check if the transport layer support cancellation\n\n          if (isCancelable(promiseOrValue)) {\n            cancelTransport = function cancelTransport() {\n              try {\n                promiseOrValue.cancel();\n              } catch (_unused) {}\n            };\n\n            _this5.isTransportCancelable = true;\n          } // Await data\n\n\n          return _await(promiseOrValue, function (_promiseOrValue) {\n            resolve(_promiseOrValue);\n          });\n        }, function (error) {\n          // Stop if the fetch is already resolved\n          if (resolved) {\n            return;\n          } // Do we need to retry the request?\n\n\n          var failureCount = _this5.state.failureCount;\n          var retry = config.retry,\n              retryDelay = config.retryDelay;\n          var shouldRetry = retry === true || failureCount < retry || typeof retry === 'function' && retry(failureCount, error);\n\n          if (!shouldRetry) {\n            // We are done if the query does not need to be retried\n            reject(error);\n            return;\n          } // Increase the failureCount\n\n\n          _this5.dispatch({\n            type: ActionType.Failed\n          }); // Delay\n\n\n          return _await(sleep(functionalUpdate(retryDelay, failureCount) || 0), function () {\n            // Pause retry if the document is not visible or when the device is offline\n            return _invoke(function () {\n              if (!isDocumentVisible() || !isOnline()) {\n                return _awaitIgnored(new Promise(function (continueResolve) {\n                  continueLoop = continueResolve;\n                }));\n              }\n            }, function () {\n              if (!resolved) {\n                run();\n              }\n            }); // Try again if not resolved yet\n          });\n        });\n      }); // Start loop\n\n\n      run();\n    });\n  };\n\n  return Query;\n}();\n\nfunction getLastPage(pages, previous) {\n  return previous ? pages[0] : pages[pages.length - 1];\n}\n\nfunction hasMorePages(config, pages, previous) {\n  if (config.infinite && config.getFetchMore && Array.isArray(pages)) {\n    return Boolean(config.getFetchMore(getLastPage(pages, previous), pages));\n  }\n}\n\nfunction getDefaultState(config) {\n  var data = typeof config.initialData === 'function' ? config.initialData() : config.initialData;\n  var status = typeof data !== 'undefined' ? QueryStatus.Success : config.enabled ? QueryStatus.Loading : QueryStatus.Idle;\n  return {\n    canFetchMore: hasMorePages(config, data),\n    data: data,\n    error: null,\n    failureCount: 0,\n    isFetching: status === QueryStatus.Loading,\n    isFetchingMore: false,\n    isInitialData: true,\n    isInvalidated: false,\n    status: status,\n    updateCount: 0,\n    updatedAt: Date.now()\n  };\n}\n\nexport function queryReducer(state, action) {\n  var _action$updatedAt;\n\n  switch (action.type) {\n    case ActionType.Failed:\n      return _extends({}, state, {\n        failureCount: state.failureCount + 1\n      });\n\n    case ActionType.Fetch:\n      return _extends({}, state, {\n        failureCount: 0,\n        isFetching: true,\n        isFetchingMore: action.isFetchingMore || false,\n        status: typeof state.data !== 'undefined' ? QueryStatus.Success : QueryStatus.Loading\n      });\n\n    case ActionType.Success:\n      return _extends({}, state, {\n        canFetchMore: action.canFetchMore,\n        data: action.data,\n        error: null,\n        failureCount: 0,\n        isFetching: false,\n        isFetchingMore: false,\n        isInitialData: false,\n        isInvalidated: false,\n        status: QueryStatus.Success,\n        updateCount: state.updateCount + 1,\n        updatedAt: (_action$updatedAt = action.updatedAt) != null ? _action$updatedAt : Date.now()\n      });\n\n    case ActionType.Error:\n      return _extends({}, state, {\n        error: action.error,\n        failureCount: state.failureCount + 1,\n        isFetching: false,\n        isFetchingMore: false,\n        status: QueryStatus.Error,\n        throwInErrorBoundary: true,\n        updateCount: state.updateCount + 1\n      });\n\n    case ActionType.Invalidate:\n      return _extends({}, state, {\n        isInvalidated: true\n      });\n\n    default:\n      return state;\n  }\n}"]},"metadata":{},"sourceType":"module"}