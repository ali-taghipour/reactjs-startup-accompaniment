{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport { getStatusProps, isDocumentVisible, isServer, isValidTimeout, noop } from './utils';\nimport { notifyManager } from './notifyManager';\nimport { DEFAULT_CONFIG, isResolvedQueryConfig } from './config';\nexport var QueryObserver = /*#__PURE__*/function () {\n  function QueryObserver(config) {\n    this.config = config;\n    this.isStale = true;\n    this.initialUpdateCount = 0; // Bind exposed methods\n\n    this.remove = this.remove.bind(this);\n    this.refetch = this.refetch.bind(this);\n    this.fetchMore = this.fetchMore.bind(this);\n    this.unsubscribe = this.unsubscribe.bind(this); // Subscribe to the query\n\n    this.updateQuery();\n  }\n\n  var _proto = QueryObserver.prototype;\n\n  _proto.subscribe = function subscribe(listener) {\n    this.listener = listener || noop;\n    this.currentQuery.subscribeObserver(this);\n\n    if (this.config.enabled && (this.config.forceFetchOnMount || this.config.refetchOnMount === 'always')) {\n      this.fetch();\n    } else {\n      this.optionalFetch();\n    }\n\n    this.updateTimers();\n    return this.unsubscribe;\n  };\n\n  _proto.unsubscribe = function unsubscribe() {\n    this.listener = undefined;\n    this.clearTimers();\n    this.currentQuery.unsubscribeObserver(this);\n  };\n\n  _proto.updateConfig = function updateConfig(config) {\n    var prevConfig = this.config;\n    var prevQuery = this.currentQuery;\n    this.config = isResolvedQueryConfig(config) ? config : this.config.queryCache.getResolvedQueryConfig(this.config.queryKey, config);\n    this.updateQuery(); // Take no further actions if there is no subscriber\n\n    if (!this.listener) {\n      return;\n    } // If we subscribed to a new query, optionally fetch and update refetch\n\n\n    if (this.currentQuery !== prevQuery) {\n      this.optionalFetch();\n      this.updateTimers();\n      return;\n    } // Optionally fetch if the query became enabled\n\n\n    if (config.enabled && !prevConfig.enabled) {\n      this.optionalFetch();\n    } // Update stale interval if needed\n\n\n    if (config.enabled !== prevConfig.enabled || config.staleTime !== prevConfig.staleTime) {\n      this.updateStaleTimeout();\n    } // Update refetch interval if needed\n\n\n    if (config.enabled !== prevConfig.enabled || config.refetchInterval !== prevConfig.refetchInterval) {\n      this.updateRefetchInterval();\n    }\n  };\n\n  _proto.getCurrentQuery = function getCurrentQuery() {\n    return this.currentQuery;\n  };\n\n  _proto.getCurrentResult = function getCurrentResult() {\n    return this.currentResult;\n  }\n  /**\n   * @deprecated\n   */\n  ;\n\n  _proto.clear = function clear() {\n    this.remove();\n  };\n\n  _proto.remove = function remove() {\n    this.currentQuery.remove();\n  };\n\n  _proto.refetch = function refetch(options) {\n    return this.currentQuery.refetch(options, this.config);\n  };\n\n  _proto.fetchMore = function fetchMore(fetchMoreVariable, options) {\n    return this.currentQuery.fetchMore(fetchMoreVariable, options, this.config).catch(noop);\n  };\n\n  _proto.fetch = function fetch() {\n    var _DEFAULT_CONFIG$queri; // Never try to fetch if no query function has been set\n\n\n    if (this.config.queryFn === ((_DEFAULT_CONFIG$queri = DEFAULT_CONFIG.queries) == null ? void 0 : _DEFAULT_CONFIG$queri.queryFn)) {\n      return Promise.resolve(this.currentResult.data);\n    }\n\n    return this.currentQuery.fetch(undefined, this.config).catch(noop);\n  };\n\n  _proto.optionalFetch = function optionalFetch() {\n    if (this.config.enabled && // Only fetch if enabled\n    this.isStale && // Only fetch if stale\n    !(this.config.suspense && this.currentResult.isFetched) && ( // Don't refetch if in suspense mode and the data is already fetched\n    this.config.refetchOnMount || this.currentQuery.observers.length === 1)) {\n      this.fetch();\n    }\n  };\n\n  _proto.updateStaleTimeout = function updateStaleTimeout() {\n    var _this = this;\n\n    if (isServer) {\n      return;\n    }\n\n    this.clearStaleTimeout();\n\n    if (this.isStale || !isValidTimeout(this.config.staleTime)) {\n      return;\n    }\n\n    var timeElapsed = Date.now() - this.currentResult.updatedAt;\n    var timeUntilStale = this.config.staleTime - timeElapsed + 1;\n    var timeout = Math.max(timeUntilStale, 0);\n    this.staleTimeoutId = setTimeout(function () {\n      if (!_this.isStale) {\n        _this.isStale = true;\n\n        _this.updateResult();\n\n        _this.notify({\n          listener: true,\n          globalListeners: true\n        });\n      }\n    }, timeout);\n  };\n\n  _proto.updateRefetchInterval = function updateRefetchInterval() {\n    var _this2 = this;\n\n    if (isServer) {\n      return;\n    }\n\n    this.clearRefetchInterval();\n\n    if (!this.config.enabled || !isValidTimeout(this.config.refetchInterval)) {\n      return;\n    }\n\n    this.refetchIntervalId = setInterval(function () {\n      if (_this2.config.refetchIntervalInBackground || isDocumentVisible()) {\n        _this2.fetch();\n      }\n    }, this.config.refetchInterval);\n  };\n\n  _proto.updateTimers = function updateTimers() {\n    this.updateStaleTimeout();\n    this.updateRefetchInterval();\n  };\n\n  _proto.clearTimers = function clearTimers() {\n    this.clearStaleTimeout();\n    this.clearRefetchInterval();\n  };\n\n  _proto.clearStaleTimeout = function clearStaleTimeout() {\n    if (this.staleTimeoutId) {\n      clearInterval(this.staleTimeoutId);\n      this.staleTimeoutId = undefined;\n    }\n  };\n\n  _proto.clearRefetchInterval = function clearRefetchInterval() {\n    if (this.refetchIntervalId) {\n      clearInterval(this.refetchIntervalId);\n      this.refetchIntervalId = undefined;\n    }\n  };\n\n  _proto.updateResult = function updateResult() {\n    var _this$previousQueryRe;\n\n    var state = this.currentQuery.state;\n    var data = state.data,\n        status = state.status,\n        updatedAt = state.updatedAt;\n    var isPreviousData = false; // Keep previous data if needed\n\n    if (this.config.keepPreviousData && state.isInitialData && ((_this$previousQueryRe = this.previousQueryResult) == null ? void 0 : _this$previousQueryRe.isSuccess)) {\n      data = this.previousQueryResult.data;\n      updatedAt = this.previousQueryResult.updatedAt;\n      status = this.previousQueryResult.status;\n      isPreviousData = true;\n    }\n\n    this.currentResult = _extends({}, getStatusProps(status), {\n      canFetchMore: state.canFetchMore,\n      clear: this.remove,\n      data: data,\n      error: state.error,\n      failureCount: state.failureCount,\n      fetchMore: this.fetchMore,\n      isFetched: state.updateCount > 0,\n      isFetchedAfterMount: state.updateCount > this.initialUpdateCount,\n      isFetching: state.isFetching,\n      isFetchingMore: state.isFetchingMore,\n      isInitialData: state.isInitialData,\n      isPreviousData: isPreviousData,\n      isStale: this.isStale,\n      refetch: this.refetch,\n      remove: this.remove,\n      updatedAt: updatedAt\n    });\n  };\n\n  _proto.updateQuery = function updateQuery() {\n    var config = this.config;\n    var prevQuery = this.currentQuery;\n    var query = config.queryCache.getQueryByHash(config.queryHash);\n\n    if (!query) {\n      query = config.queryCache.createQuery(config);\n    }\n\n    if (query === prevQuery) {\n      return;\n    }\n\n    this.previousQueryResult = this.currentResult;\n    this.currentQuery = query;\n    this.initialUpdateCount = query.state.updateCount; // Update stale state on query switch\n\n    if (query.state.isInitialData) {\n      if (config.keepPreviousData && prevQuery) {\n        this.isStale = true;\n      } else if (typeof config.initialStale === 'function') {\n        this.isStale = config.initialStale();\n      } else if (typeof config.initialStale === 'boolean') {\n        this.isStale = config.initialStale;\n      } else {\n        this.isStale = typeof query.state.data === 'undefined';\n      }\n    } else {\n      this.isStale = query.isStaleByTime(config.staleTime);\n    }\n\n    this.updateResult();\n\n    if (this.listener) {\n      prevQuery == null ? void 0 : prevQuery.unsubscribeObserver(this);\n      this.currentQuery.subscribeObserver(this);\n    }\n  };\n\n  _proto.onQueryUpdate = function onQueryUpdate(action) {\n    var config = this.config;\n    var type = action.type; // Update stale state on success, error or invalidation\n\n    if (type === 2 || type === 3 || type === 4) {\n      this.isStale = this.currentQuery.isStaleByTime(config.staleTime);\n    } // Store current result and get new result\n\n\n    var prevResult = this.currentResult;\n    this.updateResult();\n    var currentResult = this.currentResult; // Update timers on success, error or invalidation\n\n    if (type === 2 || type === 3 || type === 4) {\n      this.updateTimers();\n    } // Do not notify if the query was invalidated but the stale state did not changed\n\n\n    if (type === 4 && currentResult.isStale === prevResult.isStale) {\n      return;\n    } // Determine which callbacks to trigger\n\n\n    var notifyOptions = {};\n\n    if (type === 2) {\n      notifyOptions.onSuccess = true;\n    } else if (type === 3) {\n      notifyOptions.onError = true;\n    }\n\n    if ( // Always notify if notifyOnStatusChange is set\n    config.notifyOnStatusChange || // Otherwise only notify on data or error change\n    currentResult.data !== prevResult.data || currentResult.error !== prevResult.error) {\n      notifyOptions.listener = true;\n    }\n\n    this.notify(notifyOptions);\n  };\n\n  _proto.notify = function notify(options) {\n    var config = this.config,\n        currentResult = this.currentResult,\n        currentQuery = this.currentQuery,\n        listener = this.listener;\n    var onSuccess = config.onSuccess,\n        onSettled = config.onSettled,\n        onError = config.onError;\n    notifyManager.batch(function () {\n      // First trigger the configuration callbacks\n      if (options.onSuccess) {\n        if (onSuccess) {\n          notifyManager.schedule(function () {\n            onSuccess(currentResult.data);\n          });\n        }\n\n        if (onSettled) {\n          notifyManager.schedule(function () {\n            onSettled(currentResult.data, null);\n          });\n        }\n      } else if (options.onError) {\n        if (onError) {\n          notifyManager.schedule(function () {\n            onError(currentResult.error);\n          });\n        }\n\n        if (onSettled) {\n          notifyManager.schedule(function () {\n            onSettled(undefined, currentResult.error);\n          });\n        }\n      } // Then trigger the listener\n\n\n      if (options.listener && listener) {\n        notifyManager.schedule(function () {\n          listener(currentResult);\n        });\n      } // Then the global listeners\n\n\n      if (options.globalListeners) {\n        config.queryCache.notifyGlobalListeners(currentQuery);\n      }\n    });\n  };\n\n  return QueryObserver;\n}();","map":{"version":3,"sources":["/home/ali/reactjs-startup-accompaniment/node_modules/react-query/es/core/queryObserver.js"],"names":["_extends","getStatusProps","isDocumentVisible","isServer","isValidTimeout","noop","notifyManager","DEFAULT_CONFIG","isResolvedQueryConfig","QueryObserver","config","isStale","initialUpdateCount","remove","bind","refetch","fetchMore","unsubscribe","updateQuery","_proto","prototype","subscribe","listener","currentQuery","subscribeObserver","enabled","forceFetchOnMount","refetchOnMount","fetch","optionalFetch","updateTimers","undefined","clearTimers","unsubscribeObserver","updateConfig","prevConfig","prevQuery","queryCache","getResolvedQueryConfig","queryKey","staleTime","updateStaleTimeout","refetchInterval","updateRefetchInterval","getCurrentQuery","getCurrentResult","currentResult","clear","options","fetchMoreVariable","catch","_DEFAULT_CONFIG$queri","queryFn","queries","Promise","resolve","data","suspense","isFetched","observers","length","_this","clearStaleTimeout","timeElapsed","Date","now","updatedAt","timeUntilStale","timeout","Math","max","staleTimeoutId","setTimeout","updateResult","notify","globalListeners","_this2","clearRefetchInterval","refetchIntervalId","setInterval","refetchIntervalInBackground","clearInterval","_this$previousQueryRe","state","status","isPreviousData","keepPreviousData","isInitialData","previousQueryResult","isSuccess","canFetchMore","error","failureCount","updateCount","isFetchedAfterMount","isFetching","isFetchingMore","query","getQueryByHash","queryHash","createQuery","initialStale","isStaleByTime","onQueryUpdate","action","type","prevResult","notifyOptions","onSuccess","onError","notifyOnStatusChange","onSettled","batch","schedule","notifyGlobalListeners"],"mappings":"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","sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport { getStatusProps, isDocumentVisible, isServer, isValidTimeout, noop } from './utils';\nimport { notifyManager } from './notifyManager';\nimport { DEFAULT_CONFIG, isResolvedQueryConfig } from './config';\nexport var QueryObserver = /*#__PURE__*/function () {\n  function QueryObserver(config) {\n    this.config = config;\n    this.isStale = true;\n    this.initialUpdateCount = 0; // Bind exposed methods\n\n    this.remove = this.remove.bind(this);\n    this.refetch = this.refetch.bind(this);\n    this.fetchMore = this.fetchMore.bind(this);\n    this.unsubscribe = this.unsubscribe.bind(this); // Subscribe to the query\n\n    this.updateQuery();\n  }\n\n  var _proto = QueryObserver.prototype;\n\n  _proto.subscribe = function subscribe(listener) {\n    this.listener = listener || noop;\n    this.currentQuery.subscribeObserver(this);\n\n    if (this.config.enabled && (this.config.forceFetchOnMount || this.config.refetchOnMount === 'always')) {\n      this.fetch();\n    } else {\n      this.optionalFetch();\n    }\n\n    this.updateTimers();\n    return this.unsubscribe;\n  };\n\n  _proto.unsubscribe = function unsubscribe() {\n    this.listener = undefined;\n    this.clearTimers();\n    this.currentQuery.unsubscribeObserver(this);\n  };\n\n  _proto.updateConfig = function updateConfig(config) {\n    var prevConfig = this.config;\n    var prevQuery = this.currentQuery;\n    this.config = isResolvedQueryConfig(config) ? config : this.config.queryCache.getResolvedQueryConfig(this.config.queryKey, config);\n    this.updateQuery(); // Take no further actions if there is no subscriber\n\n    if (!this.listener) {\n      return;\n    } // If we subscribed to a new query, optionally fetch and update refetch\n\n\n    if (this.currentQuery !== prevQuery) {\n      this.optionalFetch();\n      this.updateTimers();\n      return;\n    } // Optionally fetch if the query became enabled\n\n\n    if (config.enabled && !prevConfig.enabled) {\n      this.optionalFetch();\n    } // Update stale interval if needed\n\n\n    if (config.enabled !== prevConfig.enabled || config.staleTime !== prevConfig.staleTime) {\n      this.updateStaleTimeout();\n    } // Update refetch interval if needed\n\n\n    if (config.enabled !== prevConfig.enabled || config.refetchInterval !== prevConfig.refetchInterval) {\n      this.updateRefetchInterval();\n    }\n  };\n\n  _proto.getCurrentQuery = function getCurrentQuery() {\n    return this.currentQuery;\n  };\n\n  _proto.getCurrentResult = function getCurrentResult() {\n    return this.currentResult;\n  }\n  /**\n   * @deprecated\n   */\n  ;\n\n  _proto.clear = function clear() {\n    this.remove();\n  };\n\n  _proto.remove = function remove() {\n    this.currentQuery.remove();\n  };\n\n  _proto.refetch = function refetch(options) {\n    return this.currentQuery.refetch(options, this.config);\n  };\n\n  _proto.fetchMore = function fetchMore(fetchMoreVariable, options) {\n    return this.currentQuery.fetchMore(fetchMoreVariable, options, this.config).catch(noop);\n  };\n\n  _proto.fetch = function fetch() {\n    var _DEFAULT_CONFIG$queri;\n\n    // Never try to fetch if no query function has been set\n    if (this.config.queryFn === ((_DEFAULT_CONFIG$queri = DEFAULT_CONFIG.queries) == null ? void 0 : _DEFAULT_CONFIG$queri.queryFn)) {\n      return Promise.resolve(this.currentResult.data);\n    }\n\n    return this.currentQuery.fetch(undefined, this.config).catch(noop);\n  };\n\n  _proto.optionalFetch = function optionalFetch() {\n    if (this.config.enabled && // Only fetch if enabled\n    this.isStale && // Only fetch if stale\n    !(this.config.suspense && this.currentResult.isFetched) && ( // Don't refetch if in suspense mode and the data is already fetched\n    this.config.refetchOnMount || this.currentQuery.observers.length === 1)) {\n      this.fetch();\n    }\n  };\n\n  _proto.updateStaleTimeout = function updateStaleTimeout() {\n    var _this = this;\n\n    if (isServer) {\n      return;\n    }\n\n    this.clearStaleTimeout();\n\n    if (this.isStale || !isValidTimeout(this.config.staleTime)) {\n      return;\n    }\n\n    var timeElapsed = Date.now() - this.currentResult.updatedAt;\n    var timeUntilStale = this.config.staleTime - timeElapsed + 1;\n    var timeout = Math.max(timeUntilStale, 0);\n    this.staleTimeoutId = setTimeout(function () {\n      if (!_this.isStale) {\n        _this.isStale = true;\n\n        _this.updateResult();\n\n        _this.notify({\n          listener: true,\n          globalListeners: true\n        });\n      }\n    }, timeout);\n  };\n\n  _proto.updateRefetchInterval = function updateRefetchInterval() {\n    var _this2 = this;\n\n    if (isServer) {\n      return;\n    }\n\n    this.clearRefetchInterval();\n\n    if (!this.config.enabled || !isValidTimeout(this.config.refetchInterval)) {\n      return;\n    }\n\n    this.refetchIntervalId = setInterval(function () {\n      if (_this2.config.refetchIntervalInBackground || isDocumentVisible()) {\n        _this2.fetch();\n      }\n    }, this.config.refetchInterval);\n  };\n\n  _proto.updateTimers = function updateTimers() {\n    this.updateStaleTimeout();\n    this.updateRefetchInterval();\n  };\n\n  _proto.clearTimers = function clearTimers() {\n    this.clearStaleTimeout();\n    this.clearRefetchInterval();\n  };\n\n  _proto.clearStaleTimeout = function clearStaleTimeout() {\n    if (this.staleTimeoutId) {\n      clearInterval(this.staleTimeoutId);\n      this.staleTimeoutId = undefined;\n    }\n  };\n\n  _proto.clearRefetchInterval = function clearRefetchInterval() {\n    if (this.refetchIntervalId) {\n      clearInterval(this.refetchIntervalId);\n      this.refetchIntervalId = undefined;\n    }\n  };\n\n  _proto.updateResult = function updateResult() {\n    var _this$previousQueryRe;\n\n    var state = this.currentQuery.state;\n    var data = state.data,\n        status = state.status,\n        updatedAt = state.updatedAt;\n    var isPreviousData = false; // Keep previous data if needed\n\n    if (this.config.keepPreviousData && state.isInitialData && ((_this$previousQueryRe = this.previousQueryResult) == null ? void 0 : _this$previousQueryRe.isSuccess)) {\n      data = this.previousQueryResult.data;\n      updatedAt = this.previousQueryResult.updatedAt;\n      status = this.previousQueryResult.status;\n      isPreviousData = true;\n    }\n\n    this.currentResult = _extends({}, getStatusProps(status), {\n      canFetchMore: state.canFetchMore,\n      clear: this.remove,\n      data: data,\n      error: state.error,\n      failureCount: state.failureCount,\n      fetchMore: this.fetchMore,\n      isFetched: state.updateCount > 0,\n      isFetchedAfterMount: state.updateCount > this.initialUpdateCount,\n      isFetching: state.isFetching,\n      isFetchingMore: state.isFetchingMore,\n      isInitialData: state.isInitialData,\n      isPreviousData: isPreviousData,\n      isStale: this.isStale,\n      refetch: this.refetch,\n      remove: this.remove,\n      updatedAt: updatedAt\n    });\n  };\n\n  _proto.updateQuery = function updateQuery() {\n    var config = this.config;\n    var prevQuery = this.currentQuery;\n    var query = config.queryCache.getQueryByHash(config.queryHash);\n\n    if (!query) {\n      query = config.queryCache.createQuery(config);\n    }\n\n    if (query === prevQuery) {\n      return;\n    }\n\n    this.previousQueryResult = this.currentResult;\n    this.currentQuery = query;\n    this.initialUpdateCount = query.state.updateCount; // Update stale state on query switch\n\n    if (query.state.isInitialData) {\n      if (config.keepPreviousData && prevQuery) {\n        this.isStale = true;\n      } else if (typeof config.initialStale === 'function') {\n        this.isStale = config.initialStale();\n      } else if (typeof config.initialStale === 'boolean') {\n        this.isStale = config.initialStale;\n      } else {\n        this.isStale = typeof query.state.data === 'undefined';\n      }\n    } else {\n      this.isStale = query.isStaleByTime(config.staleTime);\n    }\n\n    this.updateResult();\n\n    if (this.listener) {\n      prevQuery == null ? void 0 : prevQuery.unsubscribeObserver(this);\n      this.currentQuery.subscribeObserver(this);\n    }\n  };\n\n  _proto.onQueryUpdate = function onQueryUpdate(action) {\n    var config = this.config;\n    var type = action.type; // Update stale state on success, error or invalidation\n\n    if (type === 2 || type === 3 || type === 4) {\n      this.isStale = this.currentQuery.isStaleByTime(config.staleTime);\n    } // Store current result and get new result\n\n\n    var prevResult = this.currentResult;\n    this.updateResult();\n    var currentResult = this.currentResult; // Update timers on success, error or invalidation\n\n    if (type === 2 || type === 3 || type === 4) {\n      this.updateTimers();\n    } // Do not notify if the query was invalidated but the stale state did not changed\n\n\n    if (type === 4 && currentResult.isStale === prevResult.isStale) {\n      return;\n    } // Determine which callbacks to trigger\n\n\n    var notifyOptions = {};\n\n    if (type === 2) {\n      notifyOptions.onSuccess = true;\n    } else if (type === 3) {\n      notifyOptions.onError = true;\n    }\n\n    if ( // Always notify if notifyOnStatusChange is set\n    config.notifyOnStatusChange || // Otherwise only notify on data or error change\n    currentResult.data !== prevResult.data || currentResult.error !== prevResult.error) {\n      notifyOptions.listener = true;\n    }\n\n    this.notify(notifyOptions);\n  };\n\n  _proto.notify = function notify(options) {\n    var config = this.config,\n        currentResult = this.currentResult,\n        currentQuery = this.currentQuery,\n        listener = this.listener;\n    var onSuccess = config.onSuccess,\n        onSettled = config.onSettled,\n        onError = config.onError;\n    notifyManager.batch(function () {\n      // First trigger the configuration callbacks\n      if (options.onSuccess) {\n        if (onSuccess) {\n          notifyManager.schedule(function () {\n            onSuccess(currentResult.data);\n          });\n        }\n\n        if (onSettled) {\n          notifyManager.schedule(function () {\n            onSettled(currentResult.data, null);\n          });\n        }\n      } else if (options.onError) {\n        if (onError) {\n          notifyManager.schedule(function () {\n            onError(currentResult.error);\n          });\n        }\n\n        if (onSettled) {\n          notifyManager.schedule(function () {\n            onSettled(undefined, currentResult.error);\n          });\n        }\n      } // Then trigger the listener\n\n\n      if (options.listener && listener) {\n        notifyManager.schedule(function () {\n          listener(currentResult);\n        });\n      } // Then the global listeners\n\n\n      if (options.globalListeners) {\n        config.queryCache.notifyGlobalListeners(currentQuery);\n      }\n    });\n  };\n\n  return QueryObserver;\n}();"]},"metadata":{},"sourceType":"module"}